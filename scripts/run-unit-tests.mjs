import assert from 'node:assert/strict';

import {
    buildReaderUrl,
    buildReaderUrlWithState,
    getBookCategories,
    getBookPartCount,
    parsePartParam
} from '../js/books-meta.js';
import { createSearchEngine, searchInBookIndex } from '../js/reader/search.js';
import {
    buildReaderUrlForState,
    parseReaderStateFromSearchParams
} from '../js/reader/url-state.js';
import { createMatchExcerpt } from '../js/search/excerpt.js';
import { normalizeArabicForSearch } from '../js/shared/arabic-search.js';

const testCases = [];

function test(name, callback) {
    testCases.push({ name, callback });
}

function buildEntry(line, chapterId = '') {
    return {
        line,
        normalizedLine: normalizeArabicForSearch(line),
        pageIndex: 0,
        chapterTitle: 'الفصل',
        chapterId
    };
}

test('books-meta: part count normalization', () => {
    assert.equal(getBookPartCount({ parts: 4 }), 4);
    assert.equal(getBookPartCount({ parts: '2' }), 2);
    assert.equal(getBookPartCount({ parts: 0 }), 1);
    assert.equal(getBookPartCount({ parts: 'abc' }), 1);
});

test('books-meta: category aggregation and dedupe', () => {
    const categories = getBookCategories({
        categories: ['الحديث', 'الفقه'],
        category: 'الفقه',
        التصنيفات: ['الحديث', 'العقائد'],
        التصنيف: 'العقائد'
    });
    assert.deepEqual(categories, ['الحديث', 'الفقه', 'العقائد']);
});

test('books-meta: part parsing and URL state building', () => {
    assert.equal(parsePartParam('part3'), 2);
    assert.equal(parsePartParam('3'), 2);
    assert.equal(parsePartParam('part0'), null);
    assert.equal(parsePartParam('invalid'), null);

    const url = buildReaderUrlWithState({ id: 'الكافي', parts: 8 }, {
        partIndex: 2,
        pageIndex: 6,
        chapterId: 'chap-9'
    });

    assert.equal(url, 'reader.html?book=%D8%A7%D9%84%D9%83%D8%A7%D9%81%D9%8A&part=part3&page=7&chapter=chap-9');
    assert.equal(buildReaderUrl({ id: 'book-x', parts: 3 }, 0), 'reader.html?book=book-x');
});

test('reader-url-state: parsing explicit and default query state', () => {
    const explicit = parseReaderStateFromSearchParams('book=abc&part=part3&page=5&chapter=chap-2');
    assert.deepEqual(explicit, {
        partIndex: 2,
        pageIndex: 4,
        chapterId: 'chap-2',
        hasExplicitPart: true,
        hasExplicitPage: true,
        hasExplicitChapter: true
    });

    const defaults = parseReaderStateFromSearchParams('book=abc');
    assert.deepEqual(defaults, {
        partIndex: null,
        pageIndex: 0,
        chapterId: '',
        hasExplicitPart: false,
        hasExplicitPage: false,
        hasExplicitChapter: false
    });
});

test('reader-url-state: URL construction for reader state', () => {
    const withPart = buildReaderUrlForState({
        currentBookId: 'book-x',
        currentPageIndex: 6,
        currentPartIndex: 1,
        currentBookPartCount: 4,
        currentChapterId: 'chapter-7'
    }, 'https://ciyoku.github.io/reader.html?book=old');

    assert.equal(
        `${withPart.pathname}?${withPart.searchParams.toString()}`,
        '/reader.html?book=book-x&page=7&part=part2&chapter=chapter-7'
    );

    const singlePart = buildReaderUrlForState({
        currentBookId: 'book-y',
        currentPageIndex: 0,
        currentPartIndex: 0,
        currentBookPartCount: 1,
        currentChapterId: ''
    }, 'https://ciyoku.github.io/reader.html');

    assert.equal(`${singlePart.pathname}?${singlePart.searchParams.toString()}`, '/reader.html?book=book-y&page=1');
});

test('reader-search: minimum words and normalized matching', () => {
    const entries = [
        buildEntry('هذا نصٌ تجريبيّ للبحث داخل الكتاب'),
        buildEntry('سطر آخر بلا تطابق')
    ];

    assert.deepEqual(searchInBookIndex(entries, 'نص'), {
        normalizedQuery: '',
        matches: []
    });

    const result = searchInBookIndex(entries, 'نص تجريبي');
    assert.equal(result.matches.length, 1);
    assert.equal(result.matches[0].line, 'هذا نصٌ تجريبيّ للبحث داخل الكتاب');
});

test('reader-search: token indexing narrows candidates', () => {
    const engine = createSearchEngine([
        buildEntry('الكافي حديث التوحيد'),
        buildEntry('الفقه العملي'),
        buildEntry('الحديث والتفسير')
    ]);
    const result = searchInBookIndex(engine, 'حديث التوحيد');
    assert.equal(result.matches.length, 1);
    assert.equal(result.matches[0].line, 'الكافي حديث التوحيد');
});

test('search-excerpt: short text passthrough and long text clipping', () => {
    const shortLine = 'هذا سطر قصير جدًا';
    assert.equal(createMatchExcerpt(shortLine, normalizeArabicForSearch('سطر')), shortLine);

    const longLine = `${'مقدمة طويلة '.repeat(20)}موضوع البحث المهم${' خاتمة '.repeat(20)}`;
    const clipped = createMatchExcerpt(longLine, normalizeArabicForSearch('موضوع البحث'), { radius: 30 });

    assert.ok(clipped.includes('موضوع البحث المهم'));
    assert.ok(clipped.startsWith('…') || clipped.endsWith('…'));
    assert.ok(clipped.length < longLine.length);
});

let passed = 0;
let failed = 0;

for (const { name, callback } of testCases) {
    try {
        await callback();
        passed += 1;
        console.log(`PASS ${name}`);
    } catch (error) {
        failed += 1;
        console.error(`FAIL ${name}`);
        console.error(error.stack || error.message);
    }
}

console.log(`\nTest summary: ${passed} passed, ${failed} failed, ${testCases.length} total.`);
if (failed > 0) {
    process.exitCode = 1;
}
